import React from "react";
import Post from "../../components/posts/Post";
import { useRouter } from "next/router";
// import Comment from "../../models/comment";

// import { useSession, getSession } from "next-auth/react";
import { appToastContext } from "../../context/state";
import Spinner from "@/components/ui/Spinner";
import Head from "next/head";
// import PostId from "../../models/post";
// import Reply from "../../models/replies";
// import dbConnect from "../../middleware/mongodb";
// import post from "@/models/post";

// import useSWR from "swr";
// import fetcher from "middleware/fetch/fetch";

// import { MongoClient, ObjectID } from "mongodb";

function SinglePost(props) {
  const { useFetch, userSession } = React.useContext(appToastContext);
  const router = useRouter();
  const [post, setPost] = React.useState({
    isLoading: true,
    post: null
  })
  // const [postId, setPostId] = React.useState(null)
  // const queryParams = new URL(document.location.href).pathname;


  const getPost = async (params) => {

    const res = await useFetch("GET", `/api${params}`);

    res.data.success === true && (setPost(
      {
        isLoading: false,
        post: res.data.post
      }
    ));
  };


  React.useEffect(() => {
    const queryParams = new URL(document.location.href).pathname;
    ;

    // check if post is null and is post id does not equal query id
    post.post !== null && (queryParams !== `/post/${post.post._id}`) && setPost({ isLoading: true, post: null });
    post.isLoading && getPost(queryParams)


    router.beforePopState(() => {
      let loaded = JSON.parse(localStorage.getItem("postLoaded"));
      loaded.popState = {
        timestamp: new Date().getTime(),
      };
      localStorage.setItem("postLoaded", JSON.stringify(loaded));

      return true;
    });
    // return true;
  }, [router, post.isLoading]);
  // React.useEffect(() => {
  //   window.history.replaceState(
  //     {},
  //     "",
  //     `/post/${props.post.title.split(" ").join("-")}`
  //   );
  //   // Always do navigations after the first render
  //   // router.push(`/post/${props.post.title}`, `/post/${props.post.title}`, {
  //   //   shallow: true,
  //   // });
  // }, []);
  return (
    <>
      {
        post.isLoading ? (
          <>
            <Head>
              <title>{`loading...`}</title>
              <meta name="description" content="Generated by create next app" />
              <link rel="icon" href="/favicon.ico" />
            </Head>
            <Spinner />

          </>
        ) : (
          <>

            {!post.isLoading && (userSession ? <Post user={userSession.user} post={post.post} /> : <Post post={post.post} />)}
            {/* {!userSession && <Post post={props.post} />} */}
          </>)
      }

    </>
  );
}

// export async function getServerSideProps(context) {
//   // console.info("post component");
//   const postId = context.params.id;

//   const response = await fetch(`${server}/api/post/${postId}`);

//   const post = await response.json();

//   // console.log(post.data);

//   const comments = await post.comments;

//   return {
//     props: {
//       post: post.data,
//     },
//   };
// }

// export async function getServerSideProps(context) {
//   await dbConnect();

//   const postId = context.params.id;
//   const post = await PostId.findById(postId).populate({
//     path: "comments",
//     options: { sort: { created: -1 } },
//   });
//   //===== recursion function to find all replies =====
//   async function deepIterator(comment) {
//     let commentReplies = comment;
//     for (const key in commentReplies) {
//       if (commentReplies[key].replies !== undefined) {
//         // console.log(commentReplies[key].replies);
//         for (const com in commentReplies[key].replies) {
//           // console.log(commentReplies[key].replies[com].toString());
//           const commentReply = await Reply.findById(
//             commentReplies[key].replies[com].toString()
//           );
//           // if (commentReply === null) {
//           //   commentReplies[key].replies.spice(
//           //     commentReplies[key].replies[com]
//           //   );
//           //   console.log(commentReplies[key].replies);
//           // }
//           if (commentReply !== null) {
//             commentReplies[key].repliesFound.push(commentReply);
//           }
//           // commentReplies[key].repliesFound.push(commentReply);
//         }
//         if (commentReplies[key].repliesFound !== undefined) {
//           // console.log("if is undefined is running");
//           await deepIterator(commentReplies[key].repliesFound);
//         }
//       }
//     }

//     return commentReplies;
//   }
//   // console.log(post.comments);
//   if (post.comments !== undefined) {
//     const allReplies = await deepIterator(post.comments);
//     // const newReplies = await allReplies.repliesFound;
//     // console.log(allReplies);
//     post.comments = await allReplies;
//     // console.log(post.comments);
//   }
//   // const transformedPost = {
//   //   ...post._doc,
//   //   userProfile: {
//   //     ...post.userProfile,
//   //     id: post.userProfile.id.toString(),
//   //   },
//   //   _id: post._id.toString(),
//   //   created: post.created.toDateString(),
//   //   createdAt: post.createdAt.toDateString(),
//   //   updatedAt: post.updatedAt.toDateString(),
//   // };

//   // const newPost = await transformedPost(post);
//   // console.log(JSON.stringify(post));
//   const tranfromToJson = async (post) => {
//     return JSON.stringify(post);
//   };
//   const newData = await tranfromToJson(post);
//   // console.log(newData);
//   return {
//     props: { post: JSON.parse(newData) },
//   };
// }

export default SinglePost;
